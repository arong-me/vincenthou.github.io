首先自我检讨一下，最近一直忙于业务开发（都是借口 :no_good: ）已经有好长时间没有写文章了，现在团队里面为了提高开发的效率，也是提高大家技术深度上的积累，采用了前后端分离的开发方式。这本不是什么新鲜的模式：前端使用AJAX异步跟服务器进行数据交互，后端开发专注于业务逻辑的实现，负责产生业务model，前后端的集成通过RESTful API实现。在实践开发中遇到了些问题，通过搜索找到些通用的解决方案，再此整理下。
# 前后端集成的石器时代

现在项目里面开发的一般流程会是这样，在拿到产品团队给出的story，我会拆分成可实现的细粒度前后端任务，根据情况分配给前后端开发的同事实现。在开发实际功能时，会要求后端开发的同事提供API定义的文档（无文档不编程），前端的同事在这个间隙后去拆解页面结构，实现静态页面的实现。在后端开发的同事完成API文档之后，前端的同事根据文档自己在开发页面的时候在代码里mock静态的JSON对象，同时后端的同事开始实现实际的业务代码。如果没有变化一切看上去都还很美好，但是这个世界上唯一不变的东西就是变化了~
# 前端开发的痛点
1. 在后端开发完成API文档定义之后需要手动mock实际生产环境不需要的假数据
2. 如果后端开发尚未基本完成前，如果后端有字段结构的调整，前端开发都需要重新更改mock的数据
3. 在后端开发完成后，如果有需求上的变动，前端开发都需要很被动的等待后端业务代码实际调整后（或者口头约定后）才能集成调试业务调整后的前端数据结构
# 后端开发的痛点
1. 需要认真主动维护代码和文档的同步，经常由于两者的不同步又没有及时通知给前端，会导致功能挂掉而负担责任
2. 对于自己开发的业务代码没有把控，需要在自己的postman工具中收集一堆的接口调试用例，完成后通过人工测试的方式容易出错
3. 一些通用的测试用例仍然需要自己手动编写测试脚本，复杂的业务测试不好实施（现在这块做的不好，测试完全靠人工 :disappointed: ）
# 理想的集成方案

后端开发只需要维护一份文档（markdown, yml或者JSON），这份文档的作用跟之前写的文档没有差别，可能只是格式或者语义上的转换，但这份文档应该是对前端开发和后端开发都有额外产出的：
- 前端开发：应该能够使用命令行工具打开一个本地的mock服务器，在前端统一的AJAX请求拦截器里面能够根据临时配置（例如一个debug的bool值）切换对接服务器的域名（本地就是localhost, 线上就是实际的域名），数据接口的路径不变。
- 后端开发：应该能够使用命令行工具根据文档自动生成通用的自动化测试用例，差异化的自动化测试用例支持手工编写（更好的是能集成进git的pre-commit，test不过不能提交或者合并），工具可以在实际部署的时候生成在线文档并且能够在线调试（省的还要自己维护一堆的postman接口）。
# 一些开源技术方案的收集
## API 设计
- [HTTP API design](https://github.com/interagent/http-api-design)
- [HTTP API design chinese](https://github.com/ZhangBohan/http-api-design-ZH_CN)
- [HTTP API guide](https://github.com/bolasblack/http-api-guide)
## 规范
- [JSON API](https://github.com/json-api/json-api)
- [HAL spec](https://github.com/mikekelly/hal_specification)
## 文档定义
- [api-blueprint](https://github.com/apiaryio/api-blueprint)
- [apidoc](https://github.com/apidoc/apidoc)
- [prmd](https://github.com/interagent/prmd)
## Mock 数据
- [Mock](https://github.com/nuysoft/Mock)
- [fake.js](https://github.com/Marak/faker.js)
## JSON server
- [jsonplaceholder](https://github.com/typicode/jsonplaceholder)
- [JSON server](https://github.com/typicode/json-server)
## 现成的集成方案
- [swagger](https://github.com/swagger-api)
- [RAP](https://github.com/thx/RAP)
- [几种主流API定义方式对比](http://nordicapis.com/top-specification-formats-for-rest-apis/)
## 基于文档的测试框架
- [dredd 配合 api-blueprint](https://github.com/apiaryio/dredd)
## 性能测试框架
- [Bench REST](https://github.com/jeffbski/bench-rest)
- [Go vegeta](https://github.com/tsenart/vegeta)
# 几种流行的API定义方式
## RAML (0.8, 1.0)
### 简介

最早的RAML项目开发开始于2013年9月，规范是由多家公司共同提议出来的，还成立了工作组，其中包括Box, Paypal, Cisco等公司的技术负责人。有意思的是，在github上基于RAML比较活跃的组织Mulesoft，最开始的时候是使用swagger的，但是觉得swagger更适合从头定义新的API，不适合定义现有的API就放弃了swagger。
### 定义方式
- 语言支持：支持YAML定义
- 授权方式：使用securitySchemes定义授权方式，在securedBy属性中添加需要的权限类型数组，再通过把securedBy属性全局添加或者添加到资源上来控制API的授权方式
- 有用的特性：高度的抽象能力和复用能力是RAML定义的最大特色了
- 抽象方式：通过层级化的定义方式来对资源进行分组，顶级的资源名称作为分组名称（影响到文档生成的展现），提供了对于模型定义的抽象机制，包括resourceTypes和traits, 文档中定义的很多实体支持拆分成独立的文件（docs, examples, resourceTypes, schemas, securitySchemes, traits），在主文档中通过include引入，方便抽象重复的行为， **适合于大型工程的API定义**
### 工具集
- 文档编辑工具：[API Workbench](http://apiworkbench.com/) [ATOM](https://atom.io/)插件，支持0.8和1.0版本，支持生成脚手架，语法高亮，自动补全，错误提示（外链文档会产生不必要的错误提示，应该是都当成单一文档定义方式处理了），离线预览API Console（文档工具）。[API designer](https://github.com/mulesoft/api-designer)在本地运行一个web based的文档编辑器，仅支持0.8版本的语法。
- 文档生成工具：[API Console](https://github.com/mulesoft/api-console)能够生成在线可交互的文档，使用angluar框架实现，支持作为directive引用，也支持作为iframe内嵌，可以直接调用线上服务测试（类swagger-ui的try it）。[raml2html](https://github.com/raml2html/raml2html) 简洁清新，但是功能略简单，仅仅支持文档的查看，但是可以自己定义模板
- 代码生成工具：貌似暂时没有官方统一的代码生成工具，找到写社区的，例如[go](https://github.com/EconomistDigitalSolutions/ramlapi)，还可以使用[osprey](https://github.com/mulesoft/osprey)这种工具把RAML定义的规则作为中间件引入
- 接口验证工具：[abao](https://github.com/cybertk/abao/)基于在文档中定义的schema部分来验证待测试API的有效性，在单个请求前后的有hook，在全部测试的前后也有hook，支持指定运行若干满足文件名定义规则的hook
- 接口模拟工具：[raml-mocker](https://github.com/RePoChO/raml-mocker)支持正常基于定义的mock，同时也支持使用format定义自定义类型（有点像swagger文档定义的类型扩展，但更灵活些）
### 参考文档
- [官网](http://raml.org/)
- [0.8 定义规范](https://github.com/raml-org/raml-spec/blob/master/raml-0.8.md)
- [1.0 定义规范](http://docs.raml.org/specs/1.0/) 刚出，工具链支持不完善
- [Raml APIs samples](https://github.com/raml-apis)
- [社区工具集](http://raml.org/projects/projects)
- [主要参与贡献组织 mulesoft](https://github.com/mulesoft)
## Swagger (1.0 - 1.2, 2.0)
### 简介

最早的swagger项目开发开始于2011年7月，规范和框架的实现来自于Wordnik自己的使用场景，后来变成了完全的开源项目，2016年初已经捐给了[Open API Initiative (OAI)](https://openapis.org/)，改名叫OpenAPI Sepcification，有了更官方的组织，github上的关注度[相对比较高](https://github.com/search?utf8=%E2%9C%93&q=swagger&type=Repositories&ref=searchresults)
### 定义方式
- 语言支持：支持JSON和YAML定义
- 授权方式：使用securityDefinitions定义授权方式，在编辑文档和渲染出的文档中应用，支持对于API级别使用security定义更细粒度的权限
- 有用的特性：字段类型定义中除了正常支持JSON-schema之外还提供了format的修饰符表示[更具体的类型信息](http://swagger.io/specification/#dataTypeFormat)
- 抽象方式：可以使用tag对operation对象进行分组（影响到文档生成的展现），支持通过在response里面使用$ref引用definitions里面定义的模型（#/definitions/Model），definition需要定义在JSON的root层级上才能使用这里说到$ref的语法引用到，在 **测试和校验** 的时候这点很重要。
### 工具集
- 文档编辑工具：[Online Editor](http://editor.swagger.io/) 左侧编辑文档，右侧预览效果，还能直接根据文档中定义的线上地址发送请求测试线上实际返回效果，提供在线的client和server端口模板代码生成
- 文档生成工具：[Swagger UI](https://github.com/swagger-api/swagger-ui)能够生成在线可交互的文档，生成的效果看这里[Online Preview Demo](http://petstore.swagger.io/)
- 代码生成工具：[Swagger Codegen](https://github.com/swagger-api/swagger-codegen)依赖于java的环境，根据你定义的规范生成模板代码，值得一提的是server端的模板代码支持在开发环境下mock服务数据。
- 接口验证工具：没有完全自动化的工具，因为自动的代码生成是swagger的核心特色，自动生成代码对于参数的校验，在filter，middlewire或者hook层都做掉了，但是找到基于mocha的生成自动化测试模板文件的工具 [swagger-test-templates](https://github.com/apigee-127/swagger-test-templates)，这里有个坑就是生成的模板文件使用z-schema校验json，但不支持format参数；[另外一个](https://github.com/Maks3w/SwaggerAssertions)基本的CRUD都需要人工写很多的测试代码
- 接口模拟工具：API如果是基于express的，可以用[swagger-express-middleware](https://github.com/BigstickCarpet/swagger-express-middleware)，不仅仅是mock还包括在请求参数中带上元信息，自动的参数类型转换，参数的校验等；如果用了grunt和静态文件任务connect，用[swagger-mock-api](https://github.com/dzdrazil/swagger-mock-api)会很方便。
### 参考文档
- [官网](http://swagger.io/)
- [定义规范](http://swagger.io/specification/) 实际就是2.0的规范
- [Raml APIs samples](https://github.com/raml-apis)
- [社区工具集](http://swagger.io/tools/)
- [主要参与贡献组织 swagger-api](https://github.com/swagger-api)
## API-Blueprint(1A)
### 定义方式
- 语言支持：基于markdown的规范扩展了自定义的语法
- 授权方式：通过使用+ Authenticated定义一个区块来实现，但仍然处于[草案阶段](https://github.com/apiaryio/api-blueprint-rfcs/blob/master/draft/0002-authentication.md)
- 有用的特性：可以在标题项中通过Group关键字来对资源分组，可以通过符号加占位符定义URI的模板
- 抽象方式：可以在Data Structures部分定义model并且在Attributes里面引用
### 工具集

API blueprint的工具链主要依托于[apiary](https://apiary.io/)提供的在线SAAS服务，可以很方便跟github的仓库集成，主要的工具说明官网说的[很详细](https://docs.apiary.io/tools/)了。
- 文档编辑工具：登录后使用在线的editor工具编辑，左侧编辑文档，右侧预览效果，直接调用在线的mock服务。
- 文档生成工具：文档是在发布之后生成的，支持控制访问权限。
- 代码生成工具：[Swagger Codegen](https://github.com/swagger-api/swagger-codegen)依赖于java的环境，根据你定义的规范生成模板代码，值得一提的是server端的模板代码支持在开发环境下mock服务数据。
- 接口验证工具：[dredd](https://github.com/apiaryio/dredd)，初始化的时候通过指定key，拉取你在apiary上定义的文档来进行测试。
- 接口模拟工具：在文档发布后会生成一个mock地址，直接就是一个线上的mock服务，还可以通过inspector查看mock服务被调用的情况。
### 参考文档
- [官网](https://apiblueprint.org/)
- [定义规范](https://github.com/apiaryio/api-blueprint/blob/master/API%20Blueprint%20Specification.md)
- [主要参与贡献组织 apiary](https://github.com/apiaryio)
## 文档定义转化工具
- [apitransformer](https://apitransformer.com)
- [api-sepc-converter](https://github.com/lucybot/api-spec-converter) 暂时主要支持将各种定义方式转化为swagger2.0

**这里先占个坑，等方案梳理落地后再进一步完善本文~~**
