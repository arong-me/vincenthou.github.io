# 背景

最近面试都被问到这个问题，对这个问题很有兴趣。说实在的，这个问题很好，可大可小，很能考察出一个人知识的深度和广度，正式总结一下，这里主要从应用层来说的，底层的讨论可以参考[这篇](http://fex.baidu.com/blog/2014/05/what-happen/)。
# DNS查询

浏览器是不识别域名的，在输入地址后，浏览器需要根据域名查找到实际server的IP，DNS的查询会优先从缓存中获取，这是一级一级进行的，从浏览器，操作系统(Host文件)，路由器，ISP。最新支持的技术，DNS prefetch可以对此优化。DNS Prefetch 是一种DNS 预解析技术，当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。 

``` html
<link rel="dns-prefetch" href="http://api.twitter.com"/>
```

DNS Prefetch 已经被下面的浏览器支持
Firefox: 3.5+
Chrome: Supported
Safari 5+
Opera: Unknown
IE: 9
# TCP三次握手连接

客户端向服务器端发送SYN码请求与服务器进行连接，服务器端返回ACK码响应连接请求，并且为连接分配资源，客户端返回ACK码确认连接。
![三次握手](http://hi.csdn.net/attachment/201108/7/0_1312718352k8l6.gif)
# HTTP 请求的处理

浏览器与服务器建立TCP连接之后，浏览器向服务器发送HTTP请求，如果请求地址直接对应静态、动态文件或者服务器端处理程序（某个action），正常情况返回状态码200。其他情况对应状态码：
状态码       | 对应说明
------------- | -------------
301            | 永久重定向，拥有多个域名，或者域名迁移时使用
302            | 临时重定向，可能被劫持，[与301区别](http://www.dewen.org/q/1233)
403            | 无权限访问
404            | 访问页面不存在
500            | 服务器端处理程序抛出异常
详细的状态码定义[参考](http://tool.oschina.net/commons?type=5)
如果请求中包含头信息，服务器对响应内容使用gzip压缩

``` sh
Accept-Encoding: gzip, deflate
```

响应中包含头信息

``` sh
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
```

浏览器收到服务器响应后，浏览器gzip解压，根据content type渲染响应内容并且根据设定字符集显示。
# 缓存应用
- 通过配置服务器或者服务器处理程序[返回需要的头信息](http://www.fuchaoqun.com/2009/09/php_etag_lastmodified_expires/)实现ETAG机制，可以有效减少服务器的负载，浏览器从缓存中读取静态资源内容。更加详细的总结看[这里](http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html)
- 第一次请求
  ![第一次请求](http://images.cnblogs.com/cnblogs_com/skynet/201211/201211281402437422.png)
- 之后的请求
  ![之后的请求](http://images.cnblogs.com/cnblogs_com/skynet/201211/201211281402442505.png)
- HTML5应用设置[appliction cache](http://www.w3school.com.cn/html5/html_5_app_cache.asp)

``` html
<!DOCTYPE HTML>
<html manifest="demo.appcache">
<body>
The content of the document......
</body>
</html>
```

根据manifest文件中的配置，控制文件的访问（从缓存，直接请求或者是降级的处理），详细的解释看[这里](http://www.cnblogs.com/blackbird/archive/2012/06/12/2546751.html)
# 浏览器渲染

浏览器对于返回状态码为200的页面的解析是根据文本序自上而下解析的，一般我们假定应用最佳实践（CSS置顶，JS置尾），浏览器读取到content type为html，便以html的方式解析内容，在header中读取到外链的CSS文件就加载它，但是不会影响页面的渲染，浏览器构造CSS的规则树，随着对于页面内容的解析，浏览器同时构造文档的DOM树，在CSS的规则树构建完成后会与DOM树配合生成渲染树。从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，布局渲染树。 遍历渲染树，每个节点将使用UI后端层来绘制渲染树（主要是上色）
![Main Flow](http://taligarsiel.com/Projects/webkitflow.png)
在文档加载中会解析到img标签，根据URL加载图片文件，如果没有设定图片的尺寸，在图片真正加载完成后放置在img容器中会出发浏览器的reflow。作为背景图的图片在渲染树构建的时候根据是否为display：none决定需不需要加载，一般CSS设定的背景图片会比img标签定义图片加载时间滞后，详细实验看[这里](http://www.cnblogs.com/smjack/archive/2008/08/21/1272905.html)。浏览器解析到script标签加载外部JS文件，并且执行脚本内容，如果脚本中有对于DOM元素的操作，位置布局上的改变会触发reflow，颜色样式上的改变会出发repaint。
# TCP四次握手断开

如果没有配置header中Connection字段值为Keep-Alive（http 1.0中默认是关闭的，不过现在大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求，这一步就没有了），在加载完请求页面后TCP连接会被断开。
这个断开操作可以由客户端或者服务器端任一方发起，这里以客户器端为例。客户端发送FIN码告知服务器端没有数据需要发送了（想要断开连接），服务器端返回客户端ACK码，告知客户端已经收到消息，令客户端等待，客户端进入FIN_WAIT状态。服务器端确认没有需要交互的数据后向客户端发送FIN码，并且开始准备关闭连接。客户端返回ACK码确认连接需要关闭，并且进入TIME_WAIT状态。服务器端受到ACK码后关闭连接，客户端等待一定时间后关闭连接。
![四次握手](http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif)
# AJAX交互

如果我们希望使用局部刷新页面内容，来提升页面的加载体验，在JS脚本中会向后端的rest service请求数据，在数据加载完成之后会更新局部的DOM元素，触发reflow或者是repaint。
# 总结

如果我们使用[bigpipe技术](http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html)，会在原有的模式上进行改进。浏览器发送访问请求，然后浏览器分步返回不同的pagelet的内容，BigPipe 打破了原有的顺序执行，将页面分成不同的pagelet ，如此一来，所有的pagelet 的执行时间累加起来还是原有的时间。但是， 通过叠加不同pagelet 的不同阶段的执行时间，使总的运行时间大大减少。可以看出，总体的流程是上面罗列的这些，但是不同的技术方案会产生不同的加载处理顺序，这里的总结还有不尽完善的地方，逐步改进。
# 参考
- [What really happens when you navigate to a URL](http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/)
- [How browsers work](http://taligarsiel.com/Projects/howbrowserswork1.htm)
- [TCP协议中的三次握手和四次挥手(图解)](http://blog.csdn.net/whuslei/article/details/6667471)
- [HTTP协议头部与Keep-Alive模式详解Connection: Keep-Alive/close](http://hi.baidu.com/misaiya2008/item/e254d52303114f85af48f5c7)
- [http响应Last-Modified和ETag以及Apache和Nginx中的配置](http://blog.csdn.net/21aspnet/article/details/6604805)
- [设置html页面不让浏览器缓存的方法](http://hsj69106.blog.51cto.com/1017401/286541/)
- [HTML页面元素加载顺序研究报告（1）----简单Div罗列](http://www.cnblogs.com/smjack/archive/2008/08/20/1272370.html)
